/*
Central Cal Creator by David Horstman
 Last Modified 2017/09/12
 RELEASE
 v1.1 Changes:
 -the bug with rooms is actually a bug with teacher names. Dunno if it's fixable, or if that matters.
 -added validation subroutines for timetables and calendar
 -cleaned up error messages; log file should no longer need to be cleaned
  -added support for future timetable & calendar creation from human-readable input files
 */
String version_info = "PRODID:-//David Horstman//Central Calendar Creator 1.1//EN";
PrintWriter output; //generic output for calendars
PrintWriter logFile; //the raw log file
PrintWriter userFile; //generic output for schedules
PrintWriter buildCalendarIndex; //an index of all the calendars created
Table rawRedikerData; //in Input. should end in the line "END INPUT; END INPUT"
String letterToNumber = "ABCDEFGHIJK";
String weekdayNames = "MABCTF";
Table userSchedule; //in userFiles. Also generated by generateUserSchedules();
Table schoolCalendar; //in configFiles
Table niceSchedule; //generated by buildNiceSchedule();
String timetableIndex[] = new String[25]; //all valid timetables found by the software. for 25 schedules only (add more by making string longer)
Table regularTimetable; //in configFiles
Table fridayTimetable; //in configFiles

//the column in the userSchedule where each type of data is
int nameColumn = 0;
int timeColumn = 1;
int roomColumn = 2;
int teacherColumn = 3;

String userFolder = "userFiles";
String outputFolder = "Output";
String configFolder = "configFiles";
String inputFolder = "Input";
String userPath; //can't set value until after setup
String outPath; //can't set vaule until after setup
String configPath;//can't set vaule until after setup
String inPath;//can't set vaule until after setup
String dateStamp;
import java.io.File;
void setup() {
}
void draw() {
  writeDateStamp();
  logFile = createWriter(outputFolder+"/aaaLog.txt");
  userPath = sketchPath() + "/" + userFolder;
  inPath = sketchPath() + "/" + inputFolder;
  configPath = sketchPath() + "/" + configFolder;
  outPath = sketchPath() + "/" + outputFolder;

  parseInputData(); //import from Rediker data, or custom timetables/calendar (not yet implemented)
  loadTimetables();
  validateCalendar();
  String[] filenames = listFileNames(userPath);
  buildCalendarIndex = createWriter(outputFolder+"/aaaIndex.csv");

//create a calendar for each user in the userFiles folder
  for (int i = 0; i < filenames.length; i++) {
    String personName = filenames[i].substring(0, filenames[i].indexOf("."));
    
    //set up files for each person, then proceed if there are no fatal errors (i.e. 0 returned from the function)
    if (setUpFiles(filenames[i], personName)==0) {
      writeHeader();
      populateCalendar(personName);
      finishCalendar(personName);
    }
 }
 
 
  buildCalendarIndex.flush();
  buildCalendarIndex.close();
  consoleLogPrintln("Finished making calendars.");

  closeProgram();
}
void parseInputData() {
  String inputFiles[] = listFileNames(inPath);
  if (inputFiles.length==0)
    consoleLogPrintln("No input provided! Calendars will be based on existing data.");
  else {
    consoleLogPrintln("Begin importing files in the "+inputFolder+" folder.");
    boolean addedUserData=false;
    boolean addedCustomTimetables = false;
    boolean addedCalendarFile=false;
    for (int i = 0; i < inputFiles.length; i++) {
      if (inputFiles[i].equals("rawRedikerData.csv")) {
        consoleLogPrintln("Found raw Rediker data.");
        generateUserFiles();
        addedUserData=true;
      }
    }
    if (!addedUserData)consoleLogPrintln("Note: Didn't find a file named 'rawRedikerData.csv' to import from.");
    if (!addedCustomTimetables)consoleLogPrintln("Note: Didn't find a file named 'customTimetables.csv' to import from.");
    if (!addedCalendarFile)consoleLogPrintln("Note: Didn't find a file named 'customCalendar.csv' to import from.");
  }
  consoleLogPrintln("All input parsed.");
}
void generateUserFiles() {
  consoleLogPrintln("Begin importing Rediker data.");
  boolean excludeSection = false;
  int numberOfErrors = 0;
  rawRedikerData = loadTable("Input/rawRedikerData.csv");
  if (!rawRedikerData.getString(rawRedikerData.getRowCount()-1, 0).equals("END INPUT; END INPUT")) {
    TableRow newRow = rawRedikerData.addRow();
    newRow.setString(0, "END INPUT; END INPUT");
    consoleLogPrintln("Added \"END INPUT\" line to raw Rediker data.");
  }
  for (int i = 0; i < rawRedikerData.getRowCount(); i++) {
    String currentRow = rawRedikerData.getString(i, 0);
    int findSemicolon = currentRow.indexOf("; "); //for identifying teacher name
    int findSubject = currentRow.indexOf("SUBJECT"); //for identifying header

    //stop reading at END INPUT line
    if (currentRow.indexOf("END INPUT")!=-1)break; 

    //if the row contains a teacher name, make a new file for that teacher
    if ( findSemicolon !=-1) {
      String userFileName = currentRow.substring(0, findSemicolon)+currentRow.substring(findSemicolon+2, currentRow.indexOf(" #"))+".csv";
      userFile = createWriter("userFiles/"+userFileName);
      userFile.println("Subject,Time,Room,Teacher,");
    }

    //if the row is the header before data, populate the user's schedule
    else if (findSubject !=-1) {
      i++; //skip to the row after the header
      //keep advancing row and adding data until you hit the next teacher name
      while (rawRedikerData.getString(i, 0).indexOf("; ")==-1&&i<rawRedikerData.getRowCount()) {//added a rule to prevent going past the end of the datasheet
        String nowRow = rawRedikerData.getString(i, 0);

        //extract class name; it's everything before the first space
        int firstSpace = nowRow.indexOf(" ");
        String className = nowRow.substring(0, firstSpace);

        //if the characters after the 1st space aren't numbers, they might be part of the class name
        float nextCharacter = float(nowRow.substring(firstSpace+1, firstSpace+3));
        if (Float.isNaN(nextCharacter)) {
          //instead keep reading class name until the next space after that
          className = nowRow.substring(0, nowRow.indexOf(" ", firstSpace+1));
          logFile.println("Unexpected space in class name on line "+(i+1)+". Trying "+className+" instead.");
          numberOfErrors++;
        }
        userFile.print(className);
        //extract section info - it's the last two numbers before "ALL"
        int findSemester = nowRow.indexOf("ALL"); //the semester for all classes is ALL
        String section = nowRow.substring(findSemester-7, findSemester-3)+"/"+nowRow.substring(findSemester-3, findSemester-1);
        if (!excludeSection)userFile.print(" ("+section+"),");

        //extract time value; it's after "ALL " and before the next space
        int findNextSpace = nowRow.indexOf(" ", findSemester+4);
        String time = nowRow.substring(findSemester+4, findNextSpace);
        userFile.print(time+",");

        //extract room number by searching for teacher name
        int finalSpace = nowRow.indexOf(" ", findNextSpace+1);
        //skip room number if there isn't a valid one
        if (finalSpace<0) {
          userFile.println(",");
          logFile.println("Error: Could not read room info on line "+(i+1)+". Expect errors in classroom and teacher fields.");
          numberOfErrors++;
        }
        //otherwise, add room number and teacher name
        else {
          String roomNumber = nowRow.substring(findNextSpace+1, finalSpace);
          userFile.print(roomNumber+",");
          String teacherName = nowRow.substring(finalSpace+1, nowRow.length());
          //don't print commas b/c we're outputting to CSV

          for (int j = 0; j < teacherName.length(); j++) {
            if (teacherName.charAt(j)==',');
            else userFile.print(teacherName.charAt(j));
          }
          userFile.println(",");
        }
        i++;
      }
      userFile.flush(); 
      userFile.close();
      i--;//don't increase i so you don't accidentally skip a teacher
    }
  }

  if (numberOfErrors>0)
    consoleLogPrintln("Encountered "+numberOfErrors+" parsing errors while importing Rediker data. See logfile for details.");
 else consoleLogPrintln("Finished importing Rediker data.");
}
// This function returns all the files in a directory as an array of Strings  
String[] listFileNames(String dir) {
  File file = new File(dir);
  if (file.isDirectory()) {
    String names[] = file.list();
    return names;
  } else {
    // If it's not a directory
    return null;
  }
}
void loadTimetables() {
  consoleLogPrintln("Begin loading timetables.");
  String[] timetables = listFileNames(configPath+"/Timetables");
  for (int i =0; i <timetables.length; i++) {
    if (timetables[i].indexOf("times")==-1||timetables[i].indexOf(".csv")==-1||timetables[i].indexOf("times")+5==timetables[i].indexOf(".csv"))
      consoleLogPrintln("Error on "+timetables[i]+": timetable files must begin with 'times' and end with '.csv'.");
    else if (!validateTimetables(configPath+"/Timetables/", timetables[i])); //reject timetables that fail validation
    else {
      String timetableName = timetables[i].substring(timetables[i].indexOf("times")+5, timetables[i].indexOf(".csv")); 
      timetableIndex[i]=timetableName;
      consoleLogPrintln("Loaded timetable "+timetableName+".");
    }
  }
  regularTimetable   = loadTable("configFiles/Timetables/timesRegular.csv", "header");
  fridayTimetable = loadTable("configFiles/Timetables/timesFriday.csv", "header");
  consoleLogPrintln("Finished loading timetables.");
}
//ensure there are no errors in the timetables
boolean validateTimetables(String path, String filename) {
  Table timetableTemp = loadTable(path+filename);
  String timetableName = filename.substring(filename.indexOf("times")+5, filename.indexOf(".csv")); 

  if (!timetableTemp.getString(0, 0).equals("Period")) {
    consoleLogPrintln("Error: "+filename+" does not contain a standard header.");
    return false;
  }
  for (int i= 1; i<timetableTemp.getRowCount(); i++) {
    if (timetableTemp.getInt(i, 0)>11) {
      consoleLogPrintln("Error in timetable"+timetableName+": there is no "+timetableTemp.getInt(i, 0)+"th period!");
      return false;
    } else if (timetableTemp.getInt(i, 0)<1) {
      consoleLogPrintln("Timetable "+timetableName+" contains nonstandard period "+timetableTemp.getString(i, 0)+".");
    }
    if (timetableTemp.getInt(i, 1)<10000||timetableTemp.getInt(i, 1)>240000) {
      consoleLogPrintln("Error in period "+i+" in "+timetableName+": "+timetableTemp.getInt(i, 1)+" is not a valid start time.");
      return false;
    }
    if (timetableTemp.getInt(i, 2)<10000||timetableTemp.getInt(i, 2)>240000) {
      consoleLogPrintln("Error in period "+i+" in "+timetableName+": "+timetableTemp.getInt(i, 1)+" is not a valid end time.");
      return false;
    }
  }
  return true;
}

//identify and fix any errors in the calendar
void validateCalendar() {
  consoleLogPrintln("Begin validating calendar.");
  schoolCalendar = loadTable("configFiles/schoolCalendar.csv", "header");
  for (int i = 0; i<schoolCalendar.getRowCount(); i++) {
    if (schoolCalendar.getInt(i, 0)>99991231||schoolCalendar.getInt(i, 0)<19900101) {
      consoleLogPrintln("Error: "+schoolCalendar.getString(i, 0)+" is not a valid date. Skipping that date.");
      schoolCalendar.removeRow(i);
    } else if (weekdayNames.indexOf(schoolCalendar.getString(i, 1))==-1) {
      consoleLogPrintln("Error: "+schoolCalendar.getString(i, 1)+" is not a valid weekday. Must be M, A, B, C, T, or F.");
      schoolCalendar.removeRow(i);
    } else {
      boolean timetableFound = false;
      String date = schoolCalendar.getString(i, 0).substring(4, 6)+"/"+schoolCalendar.getString(i, 0).substring(6, 8)+"/"+schoolCalendar.getString(i, 0).substring(2, 4);
      for (int j = 0; j < timetableIndex.length; j++) {
        if (schoolCalendar.getString(i, 2).equals(timetableIndex[j])) {
          timetableFound = true;
          consoleLogPrintln("Classes on "+date+" will be based on the "+timetableIndex[j]+" timetable.");
        } else if (schoolCalendar.getString(i, 2).equals(""))
          timetableFound = true;
      }
      if (!timetableFound) {
        consoleLogPrintln("Error on "+date+": "+schoolCalendar.getString(i, 2)+" is not a valid timetable. Reverting to default timetable.");
        schoolCalendar.setString(i, 2, "");
      }
    }
  }
  consoleLogPrintln("Finished validating calendar.");
}

void validateSchedule(String personName) {
  for (int i = 1; i <userSchedule.getRowCount(); i++) {
    if (userSchedule.getString(i, roomColumn).equals(""))
      consoleLogPrintln(personName+"'s class "+userSchedule.getString(i, nameColumn)+" has no listed room number.");

    //there's a bug with teacher name validation. I'll look into this.
    if (userSchedule.getString(i, teacherColumn).equals(""))
      consoleLogPrintln(personName+"'s class "+userSchedule.getString(i, nameColumn)+" has no listing for Teacher.");
    String codedSchedule = userSchedule.getString(i, timeColumn);
    boolean validTimeCode = true;
    for (int j = 0; j < codedSchedule.length(); j++) {
      if (letterToNumber.indexOf(codedSchedule.substring(j, j+1))==-1) {
        if (int(codedSchedule.substring(j, j+1))<1||int(codedSchedule.substring(j, j+1))>6) {
          if (validTimeCode)consoleLogPrintln(personName+"'s class "+userSchedule.getString(i, nameColumn)+" has an invalid timecode.");
          //println(codedSchedule.substring(j,j+1));
          validTimeCode = false;
        }
      }
    }
    if (!validTimeCode)userSchedule.setString(i, timeColumn, "");
  }
  //println(personName+"'s "+"schedule validated.");
}
//import the appropriate user schedule and other datafiles, and create an output calendar file
int setUpFiles(String filename, String personName) { 
  if (filename.indexOf(".csv")==-1) {
    consoleLogPrintln("Error: "+filename+ " is not a valid '.csv' file.");
    return 1; //error message 1
  } 
  userSchedule = loadTable(userFolder + "/" + filename);
  if (userSchedule.getRowCount()<=0) {
    consoleLogPrintln("Error: "+filename + " contains no schedule information.");
    return 2; //error message 2
  }
  String outputFilename = filename.substring(0, filename.indexOf(".csv"))+".ics";
  output = createWriter(outputFolder + "/" + outputFilename);
  validateSchedule(personName);
  buildNiceSchedule(personName);
  buildCalendarIndex.print(filename.substring(0, filename.indexOf(".csv"))+",");
  buildCalendarIndex.println("webcal://dl.dropboxusercontent.com/");

  logFile.println(personName+"'s schedule loaded successfully.");
  return 0; //no error
}

//convert from Rediker output format (A14D4K58 or similar) to a table containing day of the week and period
void buildNiceSchedule(String personName) {
  int classNumber = 1; //which class we're checking
  niceSchedule = loadTable("configFiles/blankGrid.csv");
  while (classNumber<userSchedule.getRowCount()) {

    String codedSchedule = userSchedule.getString(classNumber, timeColumn); //extract the "coded" schedule info
    int columnNumber = 0;
    int rowNumber = 0;

    for (int j = 0; j<codedSchedule.length(); j++) {
      String theCharacter = codedSchedule.substring(j, j+1); //read code character by character
      float x = float(theCharacter);
      // println(theCharacter);

      if (Float.isNaN(x)) { //if the character is a letter, define the row number
        rowNumber = letterToNumber.indexOf(theCharacter);
      } else { //if the character is a number, add an instance of the class to the niceSchedule
        columnNumber = int(x)-1;
        /*print(rowNumber); print(","); println(columnNumber);*/
        if (rowNumber==-1||columnNumber==-1||classNumber==-1); //don't try to write to an invalid location
        //consoleLogPrintln("Error: "+personName+"'s class "+userSchedule.getString(classNumber, nameColumn)+" has an invalid timecode.");
        else niceSchedule.setInt(rowNumber, columnNumber, classNumber);
      }
    }
    classNumber++;
  }
  /*  //the code here is to check buildNiceSchedule by outputting the table to file
   output=createWriter("niceScheduleTest.csv");
   for(int i = 0; i <11; i++){
   for(int j = 0; j<6;j++){
   output.print(niceSchedule.getInt(i,j));output.print(",");
   }
   output.println("");
   }
   output.flush();
   output.close();
   */
}
//add a standard header to the output iCalendar file, including timezone (Eastern)
void writeHeader() {
  output.println("BEGIN:VCALENDAR");
  output.println(version_info);
  output.println("VERSION:2.0");
  output.println("METHOD:PUBLISH");
  output.println("X-WR-CALNAME:Class Schedule");
  output.println("BEGIN:VTIMEZONE");
  output.println("TZID:America/New_York");
  output.println("X-LIC-LOCATION:America/New_York");
  output.println("BEGIN:DAYLIGHT");
  output.println("TZOFFSETFROM:-0500");
  output.println("TZOFFSETTO:-0400");
  output.println("TZNAME:EDT");
  output.println("DTSTART:19700308T020000");
  output.println("RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU");
  output.println("END:DAYLIGHT");
  output.println("BEGIN:STANDARD");
  output.println("TZOFFSETFROM:-0400");
  output.println("TZOFFSETTO:-0500");
  output.println("TZNAME:EST");
  output.println("DTSTART:19701101T020000");
  output.println("RRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU");
  output.println("END:STANDARD");
  output.println("END:VTIMEZONE");
}
//read the day of the week and prepare to add events to the calendar
void populateCalendar(String personName) {
  for (int i = 0; i<schoolCalendar.getRowCount(); i++) {//loop over the full length of the calendar
    String dayOfTheWeek = schoolCalendar.getString(i, 1);//check the day of the week
    if (dayOfTheWeek.equals("M"))
      addEvents(0, schoolCalendar.getInt(i, 0), personName, i);//pass in Monday (0) and date
    else if (dayOfTheWeek.equals("A"))
      addEvents(1, schoolCalendar.getInt(i, 0), personName, i);//pass in A Day (1) and date
    else if (dayOfTheWeek.equals("B"))
      addEvents(2, schoolCalendar.getInt(i, 0), personName, i);//etc
    else if (dayOfTheWeek.equals("C"))
      addEvents(3, schoolCalendar.getInt(i, 0), personName, i);
    else if (dayOfTheWeek.equals("T"))
      addEvents(4, schoolCalendar.getInt(i, 0), personName, i);
    else if (dayOfTheWeek.equals("F"))
      eventsFriday(5, schoolCalendar.getInt(i, 0), personName);
  }
}
//create the actual calendar events
void addEvents(int weekday, int date, String personName, int j) {
  //if a named timetable is found, generate events based on it instead of the standard timetable
  if(!schoolCalendar.getString(j,2).equals(""))
  addEventsCustom(weekday, date, personName, j);
  else{
  for (int i = 0; i <11; i++) {//iterate through all 11 periods
    int course = niceSchedule.getInt(i, weekday);
    if (course == 0); //don't create an event for a free period
    else {
      output.println("BEGIN:VEVENT");
      output.print("DTSTART;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (regularTimetable.getString(i, 1).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(regularTimetable.getString(i, 1));//print start time; using a string to keep leading 0s
      output.print("DTEND;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (regularTimetable.getString(i, 2).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(regularTimetable.getString(i, 2));//print end time; using a string to keep leading 0s
      output.println("DTSTAMP:"+dateStamp);
      output.print("SUMMARY:");
      output.println(userSchedule.getString(course, nameColumn)); //print course name
      output.print("LOCATION:");
      output.println(userSchedule.getString(course, roomColumn)); //print room number
      if (userSchedule.getString(course, roomColumn).equals("")) {
        //consoleLogPrintln("Error: "+personName+"'s class "+userSchedule.getString(course, nameColumn)+" has no room info.");
      }
      output.print("DESCRIPTION:Teacher: ");
      output.println(userSchedule.getString(course, teacherColumn)); //print teacher's name
      output.println("END:VEVENT");
    }
  }
}}
//add events with a custom timetable
void addEventsCustom(int weekday, int date, String personName, int j) {
  Table customTimetable = loadTable("configFiles/Timetables/times"+schoolCalendar.getString(j,2)+".csv","header");
  for (int i = 0; i <customTimetable.getRowCount(); i++) {//iterate through all 11 periods
  if(Float.isNaN(customTimetable.getFloat(i,0))){
  //add an assembly is the period isn't a number but instead an assembly name
    output.println("BEGIN:VEVENT");
      output.print("DTSTART;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (customTimetable.getString(i, 1).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(customTimetable.getString(i, 1));//print start time; using a string to keep leading 0s
      output.print("DTEND;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (customTimetable.getString(i, 2).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(customTimetable.getString(i, 2));//print end time; using a string to keep leading 0s
      output.println("DTSTAMP:"+dateStamp);
      output.print("SUMMARY:");
      output.println(customTimetable.getString(i,0)); //print assembly name
      output.print("LOCATION:");
      //output.println("Cafe");
      output.println("END:VEVENT");
  
  }
  else{
    int course = niceSchedule.getInt(customTimetable.getInt(i,0)-1, weekday);
    if (course == 0); //don't create an event for a free period
    else {
      output.println("BEGIN:VEVENT");
      output.print("DTSTART;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (customTimetable.getString(i, 1).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(customTimetable.getString(i, 1));//print start time; using a string to keep leading 0s
      output.print("DTEND;TZID=America/New_York:");
      output.print(date);
      output.print("T");
      if (customTimetable.getString(i, 2).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(customTimetable.getString(i, 2));//print end time; using a string to keep leading 0s
      output.println("DTSTAMP:"+dateStamp);
      output.print("SUMMARY:");
      output.println(userSchedule.getString(course, nameColumn)); //print course name
      output.print("LOCATION:");
      output.println(userSchedule.getString(course, roomColumn)); //print room number
      if (userSchedule.getString(course, roomColumn).equals("")) {
        //consoleLogPrintln("Error: "+personName+"'s class "+userSchedule.getString(course, nameColumn)+" has no room info.");
      }
      output.print("DESCRIPTION:Teacher: ");
      output.println(userSchedule.getString(course, teacherColumn)); //print teacher's name
      output.println("END:VEVENT");
    }
  }}
}


//a separate method to handle fridays, which have fewer class periods
void eventsFriday(int weekday, int date, String personName) {
  for (int i = 0; i <5; i++) {//iterate through all 5
    int course = niceSchedule.getInt(i, weekday);
    if (course == 0); //don't create an event for a free period
    else {
      output.println("BEGIN:VEVENT");
      output.print("DTSTART:");
      output.print(date);
      output.print("T");
      if (fridayTimetable.getString(i, 1).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(fridayTimetable.getString(i, 1));//print start time; using a string to keep leading 0s
      output.print("DTEND:");
      output.print(date);
      output.print("T");
      if (fridayTimetable.getString(i, 2).length()<6)output.print("0"); //fix problem with lost leading 0
      output.println(fridayTimetable.getString(i, 2));//print end time; using a string to keep leading 0s
      output.println("DTSTAMP:"+dateStamp);
      output.print("SUMMARY:");
      output.println(userSchedule.getString(course, nameColumn)); //print course name
      output.print("LOCATION:");
      output.println(userSchedule.getString(course, roomColumn)); //print room number
      if (userSchedule.getString(course, roomColumn).equals("")) {
       // consoleLogPrintln("Error: "+personName+"'s class "+userSchedule.getString(course, nameColumn)+" has no room info.");
      }
      output.print("DESCRIPTION:Teacher: ");
      output.println(userSchedule.getString(course, teacherColumn)); //print teacher's name
      output.println("END:VEVENT");
    }
  }
}
//write last line of the iCalendar and finish the file
void finishCalendar(String personName) {
  output.println("END:VCALENDAR");
  consoleLogPrintln("Calendar file created for "+personName+".");
  output.flush(); 
  output.close();
}
void writeDateStamp(){
PrintWriter temporaryFile = createWriter(outputFolder+"/zztemp.csv");
  temporaryFile.print(year());
  if(month()<10)temporaryFile.print("0");
  temporaryFile.print(month());
  if(day()<10)temporaryFile.print("0");
  temporaryFile.print(day()+"T");
  if(hour()<10)temporaryFile.print("0");
  temporaryFile.print(hour());
  if(minute()<10)temporaryFile.print("0");
  temporaryFile.print(minute());
  if(second()<10)temporaryFile.print("0");
  temporaryFile.println(second()+",,");
  temporaryFile.println(",,");
  temporaryFile.flush(); temporaryFile.close();
 Table dateTemp = loadTable(outputFolder+"/zztemp.csv");
 dateStamp = dateTemp.getString(0,0);
// consoleLogPrintln("Date stamp is "+dateStamp+".");
}
void consoleLogPrintln(String message) {
  println(message);
  logFile.println(message);
}
void consoleLogPrint(String message) {
  print(message);
  logFile.print(message);
}
void closeProgram() {
  logFile.flush();
  logFile.close();
  exit();
}